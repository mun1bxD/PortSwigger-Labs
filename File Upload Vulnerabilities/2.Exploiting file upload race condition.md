### Exploiting file upload race condition

#### Overview

The text discusses potential security vulnerabilities in file upload mechanisms, particularly focusing on race conditions. Race conditions occur when the behavior of software depends on the sequence or timing of uncontrollable events. They are often challenging to detect and exploit, especially in file upload processes.

#### Typical Safe File Upload Process

Modern frameworks usually handle file uploads securely by:
1. **Uploading to a Temporary Directory**: Files are initially uploaded to a sandboxed, temporary directory.
2. **Randomizing File Names**: Temporary file names are randomized to prevent overwriting and to avoid predictability.
3. **Validation**: Files are validated in this temporary location.
4. **Transferring Files**: Only after validation are files moved to their final destination.

This multi-step process helps prevent direct execution of malicious files and reduces the risk of race conditions.

#### Unsafe File Upload Practices

However, developers may sometimes implement their own file upload mechanisms, bypassing framework safeguards, leading to potential vulnerabilities:
1. **Direct Upload to Main Filesystem**: Files are uploaded directly to their final destination.
2. **Post-Upload Validation**: Files are validated after being uploaded. If validation fails, files are deleted.
3. **Short Time Window for Exploitation**: Even though the file exists for a short period, an attacker can exploit this window to execute the file.

#### Example of Exploiting Race Conditions

Consider a website that allows file uploads and performs post-upload validation:

1. **Upload Process**: The website uploads a file directly to `/uploads/`.
2. **Validation Process**: The website validates the file. If it contains malware, the file is deleted.

During the brief period between the file upload and its deletion, an attacker could execute the file.

#### URL-based File Uploads

Race conditions can also affect URL-based file uploads where users provide a URL, and the server fetches the file:

1. **Fetching File**: The server downloads the file to a temporary directory.
2. **Validation**: The server validates the file before processing it.

If the temporary file name is predictable or can be brute-forced, an attacker could access and execute the file during the validation process.

### Detailed Example

Imagine a vulnerable website with the following file upload process:

1. **File Upload**: A user uploads a file, which is temporarily stored in a directory like `/tmp/uploads/` with a name based on `uniqid()`.
2. **File Processing**:
    - The server validates the file.
    - If valid, it moves the file to `/uploads/`.
    - If invalid, it deletes the file from `/tmp/uploads/`.

Here’s how an attacker might exploit this:

1. **Upload Malicious File**: The attacker uploads `malicious.php`, which is temporarily stored as `/tmp/uploads/5f4dcc3b5aa765d61d8327deb882cf99.php`.
2. **Extend Processing Time**: The attacker increases the file size, causing the validation process to take longer.
3. **Brute-Force Temporary File Name**: During the extended processing time, the attacker brute-forces the file name and accesses it via `http://example.com/tmp/uploads/5f4dcc3b5aa765d61d8327deb882cf99.php`.
4. **Execute Malicious Code**: The attacker accesses the file and triggers its execution before the server deletes it.

### Mitigating Race Conditions

To prevent such vulnerabilities, developers should:
- Always use secure frameworks for handling file uploads.
- Perform validation in a secure, temporary location before moving files.
- Use strong, cryptographically secure random functions for generating temporary file names.
- Limit the window for potential exploitation by minimizing the time between file upload and validation.

By following these practices, the risk of race conditions in file uploads can be significantly reduced.

<img src="images/image35.png" alt="third" width="500">

**Step1:**

First login with given credential

**Step 2:**

First we upload a file with .php extension

<img src="images/image36.png" alt="third" width="500">

**Output**

<img src="images/image37.png" alt="third" width="500">

**Step3**

we create a file having payload

`<?php echo file_get_contents('/home/carlos/secret'); ?>`

 and save it with .png extension

<img src="images/image38.png" alt="third" width="500">

Uploading file

Now file is uploaded successfully.

**Step4**

In burpsuite we have

<img src="images/image39.png" alt="third" width="500">

Now we send Post /my-account/avatar request and GET / request file to repeater.

Because if any other get request is send it will be deleted by server. So we will not be able to execute it.

<img src="images/image40.png" alt="third" width="500">

**Step5**

Make this change in these file.

In POST /my-account/avatar  file

Change file name from payload1.php to payload1.png

<img src="images/image41.png" alt="third" width="500">

In Get/  
 
<img src="images/image42.png" alt="third" width="500">

We know that file is save at /files/avatars/payload1.png  because when we open the uploaded image in new tab it shpw the link

<img src="images/image43.png" alt="third" width="500">

Add the path  to get file but change it to payload1.php file.


**Step6**

Click on plus sign and create tab group

<img src="images/image44.png" alt="third" width="500">

<img src="images/image45.png" alt="third" width="300">

**Step7**

Select send group in parallel and click on send

<img src="images/image46.png" alt="third" width="500">

**Note:** it's quite possible you not get answer in first sended request. In this case send request continuously you will finally get the flag.
