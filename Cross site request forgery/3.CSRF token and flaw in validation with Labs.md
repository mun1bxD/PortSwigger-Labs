**What is a CSRF token?**

A CSRF token is a unique, secret, and unpredictable value that is generated by the server-side application and shared with the client. When issuing a request to perform a sensitive action, such as submitting a form, the client must include the correct CSRF token. Otherwise, the server will refuse to perform the requested action.

A common way to share CSRF tokens with the client is to include them as a hidden parameter in an HTML form, for example:
```
<form name="change-email-form" action="/my-account/change-email" method="POST">

    <label>Email</label>

    <input required type="email" name="email" value="example@normal-website.com">

    <input required type="hidden" name="csrf" value="50FaWgdOhi9M9wyna8taR1k3ODOR8d6u">

    <button class='button' type='submit'> Update email </button>

</form>
```
Submitting this form results in the following request:
```
POST /my-account/change-email HTTP/1.1

Host: normal-website.com

Content-Length: 70

Content-Type: application/x-www-form-urlencoded

csrf=50FaWgdOhi9M9wyna8taR1k3ODOR8d6u&email=example@normal-website.com
```

When implemented correctly, CSRF tokens help protect against CSRF attacks by making it difficult for an attacker to construct a valid request on behalf of the victim. As the attacker has no way of predicting the correct value for the CSRF token, they won't be able to include it in the malicious request.

**Common flaws in CSRF token validation**

CSRF vulnerabilities typically arise due to flawed validation of CSRF tokens. In this section, we'll cover some of the most common issues that enable attackers to bypass these defenses.

**Validation of CSRF token depends on request method**

Some applications correctly validate the token when the request uses the POST method but skip the validation when the GET method is used.

In this situation, the attacker can switch to the GET method to bypass the validation and deliver a CSRF attack:
```
GET /email/change?email=pwned@evil-user.net HTTP/1.1

Host: vulnerable-website.com

Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm
```

**Lab: CSRF where token validation depends on request method**

<img src="images/image8.png" alt="third" width="800">

**Step 1**  
login to account with the given credential.

**Step 2**

Update the email address.

<img src="images/image4.png" alt="third" width="800">

**Step 3**

In burp suite select the post request of email update and send it to repeater.

<img src="images/image5.png" alt="third" width="800">

**Step 4**

<img src="images/image9.png" alt="third" width="800">

Change this request method

Right click --->request method.

And we remove csrf token. because in this lab there is vulnerability to csrf with changing request.

<img src="images/image10.png" alt="third" width="800">

**Step 5**

Now generate csrf poc by right clicking and in engagement tool select generate csrf poc

<img src="images/image11.png" alt="third" width="800">

**Step 6**

Copy it and paste it in body of exploit server.

<img src="images/image12.png" alt="third" width="800">

Now store it in server and click on deliver exploit to victim.

<img src="images/image13.png" alt="third" width="800">

**Validation of CSRF token depends on token being present**

Some applications correctly validate the token when it is present but skip the validation if the token is omitted.

In this situation, the attacker can remove the entire parameter containing the token (not just its value) to bypass the validation and deliver a CSRF attack:
```
POST /email/change HTTP/1.1

Host: vulnerable-website.com

Content-Type: application/x-www-form-urlencoded

Content-Length: 25

Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm email=pwned@evil-user.net
```
<img src="images/image15.png" alt="third" width="800">

This lab is very similar to last one. There is only one change instead of changing request we simple remove csrf token then we generate

Csrf poc and store it in server.

**CSRF token is not tied to the user session**

Some applications do not validate that the token belongs to the same session as the user who is making the request. Instead, the application maintains a global pool of tokens that it has issued and accepts any token that appears in this pool.

In this situation, the attacker can log in to the application using their own account, obtain a valid token, and then feed that token to the victim user in their CSRF attack.

<img src="images/image16.png" alt="third" width="800">

This lab can be solve using one account. but the csrf token is not used. As the csrf token is generated from pool of token we can use a token for different email

**Step 1**  
login to account with the given credential.

**Step 2**

Update the email address and intercept the request.

<img src="images/image4.png" alt="third" width="800">

Then we see result in http history or in intercept pag.

<img src="images/image17.png" alt="third" width="800">

Here is the data

<img src="images/image18.png" alt="third" width="800">

we generate the csrf poc on the basis of this token

<img src="images/image19.png" alt="third" width="800">

Now open lab in new terminal and paste this in server with change email.

<img src="images/image20.png" alt="third" width="800">

click on store and then click on deliver exploit to victim.

Basically the purpose of giving two email account is to verify whether the csrf token is tied to user or not. by exchanging the csrf token and then test.

**CSRF token is tied to a non-session cookie - Continued**

This situation is harder to exploit but is still vulnerable. If the website contains any behavior that allows an attacker to set a cookie in a victim's browser, then an attack is possible. The attacker can log in to the application using their own account, obtain a valid token and associated cookie, leverage the cookie-setting behavior to place their cookie into the victim's browser, and feed their token to the victim in their CSRF attack.


**Lab: CSRF where token is tied to non-session cookie**

<img src="images/image21.png" alt="third" width="800">


**Step1**

To solve this lab we first open two account wiener:peter and carlos:montoya and then we  intercept the update email request of both user.

**Step2**

We can see the csrf and csrfkey of both user for reconnaissance. we first check whether by changing value of csrf and csrf key cause error.

<img src="images/image22.png" alt="third" width="800">

**Step3**

As it is clear by changing value of csrf and csrfkey the error occur.now we exchange value of csrf and csrfkey of both user then we check result.

**User wiener**

**Csrf**=j5j3McqGRK6SIPcjYqQVaxyl6xohQMBI

**Csrfkey**=k9vnSgJiDAQtryN7Kn3Ttmzje92fVWzG

**User carlos**

**Csrf**=q9ZXzn3PmQ1gc2xsvDPYVKAcEOg41CYn

**Csrfkey**=4E4pVduSGkSSMo90ZZJNYosmSw6TZjcs

So after change csrf and csrfkey result is clear

<img src="images/image23.png" alt="third" width="800">

**Step 4**

As vulnerability is clear. Use wiener account to craft an exploit and then send it to target victim.

First we search for something in search bar. Basically we are try to find any location in website so we can insert the csrfkey

<img src="images/image24.png" alt="third" width="800">

This is result in burpsuite

<img src="images/image26.png" alt="third" width="800">

Now we try to insert csrfkey

<img src="images/image27.png" alt="third" width="800">

 From this it is clear that we can insert csrf

**Step5**

Craft exploit

As it is mention earlier that attacker is wiener.so we intercept update email request of wiener then we catch csrf and csrfkey and send with other email to victim this is sended by opening account of wiener in new browser.once it is send then we off our intercept.

<img src="images/image28.png" alt="third" width="800">

Now we generate csrf poc and remove script for direct submission

<img src="images/image29.png" alt="third" width="800">

Now add this line

`https://0abc00120462e59382bff7ba00f100ac.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=k9vnSgJiDAQtryN7Kn3Ttmzje92fVWzG%3b%20SameSite=None`

Here
`Lab session id=0abc00120462e59382bff7ba00f100ac`

`Csrfkey=k9vnSgJiDAQtryN7Kn3Ttmzje92fVWzG`

Final look:

`<img src="https://0abc00120462e59382bff7ba00f100ac.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=k9vnSgJiDAQtryN7Kn3Ttmzje92fVWzG%3b%20SameSite=None" onerror="document.forms[0].submit()">`

<img src="images/image30.png" alt="third" width="800">

Now we login as wiener in browser and add this in exploit place in site

<img src="images/image31.png" alt="third" width="800">

- change email address

- Click on store

- Click on deliver exploit to victim

**CSRF token is simply duplicated in a cookie**

In a further variation on the preceding vulnerability, some applications do not maintain any server-side record of tokens that have been issued, but instead duplicate each token within a cookie and a request parameter. When the subsequent request is validated, the application simply verifies that the token submitted in the request parameter matches the value submitted in the cookie. This is sometimes called the "double submit" defense against CSRF, and is advocated because it is simple to implement and avoids the need for any server-side state:
```
POST /email/change HTTP/1.1

Host: vulnerable-website.com

Content-Type: application/x-www-form-urlencoded

Content-Length: 68

Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa

csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&email=wiener@normal-user.com
```
In this situation, the attacker can again perform a CSRF attack if the website contains any cookie setting functionality. Here, the attacker doesn't need to obtain a valid token of their own. They simply invent a token (perhaps in the required format, if that is being checked), leverage the cookie-setting behavior to place their cookie into the victim's browser, and feed their token to the victim in their CSRF attack

<img src="images/image32.png" alt="third" width="800">

**Solution**

This lab is very similar to the previous lab. There is only one change: we can replace csrf and csrftoken with some other value. It can be valid or not; it doesn't affect the result. However, the value should be duplicated in the cookie
