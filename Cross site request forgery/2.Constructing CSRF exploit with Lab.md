**How to construct a CSRF attack**

This is available in burpsuite professional

1. Select a request and send it to repeater
2. Right click on the request in repeater and in Engagement tool select CSRF POC

<img src="images/image2.png" alt="third" width="800">

**Lab: CSRF vulnerability with no defenses**

Step 1  

login to account with the given credential.

Step 2

<img src="images/image3.png" alt="third" width="800">

Update the email address.

Step 3

In burp suite select the post request of email update and send it to repeater.

<img src="images/image4.png" alt="third" width="800">

Step 4

In repeater generate a csrf poc.

<img src="images/image5.png" alt="third" width="800">

Step 5

1.Copy the CSRF Poc and paste it in  exploit sever body. On the lab.

2.Change email address

<img src="images/image6.png" alt="third" width="800">

Click on store and then deliver exploit to victim

**How to deliver a CSRF exploit**

The delivery mechanisms for cross-site request forgery attacks are essentially the same as for reflected XSS. Typically, the attacker will place the malicious HTML onto a website that they control, and then induce victims to visit that website. This might be done by feeding the user a link to the website, via an email or social media message. Or if the attack is placed into a popular website (for example, in a user comment), they might just wait for users to visit the website.

Note that some simple CSRF exploits employ the GET method and can be fully self-contained with a single URL on the vulnerable website. In this situation, the attacker may not need to employ an external site, and can directly feed victims a malicious URL on the vulnerable domain. In the preceding example, if the request to change email address can be performed with the GET method, then a self-contained attack would look like this:

`<img src="https://vulnerable-website.com/email/change?email=pwned@evil-user.net">`

**Common defenses against CSRF**

Nowadays, successfully finding and exploiting CSRF vulnerabilities often involves bypassing anti-CSRF measures deployed by the target website, the victim's browser, or both. The most common defenses you'll encounter are as follows:

- CSRF tokens - A CSRF token is a unique, secret, and unpredictable value that is generated by the server-side application and shared with the client. When attempting to perform a sensitive action, such as submitting a form, the client must include the correct CSRF token in the request. This makes it very difficult for an attacker to construct a valid request on behalf of the victim.
- SameSite cookies - SameSite is a browser security mechanism that determines when a website's cookies are included in requests originating from other websites. As requests to perform sensitive actions typically require an authenticated session cookie, the appropriate SameSite restrictions may prevent an attacker from triggering these actions cross-site. Since 2021, Chrome enforces Lax SameSite restrictions by default. As this is the proposed standard, we expect other major browsers to adopt this behavior in future.
- Referer-based validation - Some applications make use of the HTTP Referer header to attempt to defend against CSRF attacks, normally by verifying that the request originated from the application's own domain. This is generally less effective than CSRF token validation.
